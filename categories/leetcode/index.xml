<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on code show的博客</title>
    <link>https://CorPython.github.io/categories/leetcode/</link>
    <description>Recent content in leetcode on code show的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Mar 2020 11:04:25 +0800</lastBuildDate>
    
	<atom:link href="https://CorPython.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode108题</title>
      <link>https://CorPython.github.io/post/leetcode108/</link>
      <pubDate>Mon, 30 Mar 2020 11:04:25 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode108/</guid>
      <description>题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9</description>
    </item>
    
    <item>
      <title>leetcode169题</title>
      <link>https://CorPython.github.io/post/leetcode169%E9%A2%98/</link>
      <pubDate>Fri, 13 Mar 2020 12:29:31 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode169%E9%A2%98/</guid>
      <description>题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 题解 摩尔投票法 int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { //摩尔投票法,先假设第一个数过半数并设cnt=1； //遍历后面</description>
    </item>
    
    <item>
      <title>Leetcode82题</title>
      <link>https://CorPython.github.io/post/leetcode82%E9%A2%98/</link>
      <pubDate>Wed, 11 Mar 2020 09:11:53 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode82%E9%A2%98/</guid>
      <description>删除排序链表中的重复元素 II 题目 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 输出: 1-&amp;gt;2-&amp;gt;5 示例 2: 输入: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 输出: 2-&amp;gt;3 题解 方法1.使用unordered_map计数 class Solution { public: ListNode* deleteDuplicates(ListNode* head) { //判空 if (!head) return head; unordered_map&amp;lt;int, int&amp;gt; mp; ListNode *p = head; while (p-&amp;gt;next) { mp[p-&amp;gt;val]++; p = p-&amp;gt;next; } mp[p-&amp;gt;val]++; ListNode *dummyhead= new ListNode(0); dummyhead-&amp;gt;next = head;</description>
    </item>
    
    <item>
      <title>leetcode每日一题</title>
      <link>https://CorPython.github.io/post/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link>
      <pubDate>Fri, 06 Mar 2020 09:47:09 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid>
      <description>和为s的连续正数序列 题目 题目链接 题解 方法一:滑动窗口求解 参考题解 滑动串口为左闭右开区间,sum为[i,j)之间的数字之和, 当左边界小于等于target / 2时,有以下三种情况 sum&amp;lt;target时,右边界向右移动,sum+=j,j++ sum&amp;gt;target时,左边界向右移</description>
    </item>
    
    <item>
      <title>Leetcode面试金典</title>
      <link>https://CorPython.github.io/post/leetcode%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/</link>
      <pubDate>Wed, 04 Mar 2020 17:23:34 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/</guid>
      <description>1.判定字符是否唯一 题目 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1： 输入: s = &amp;quot;leetcode&amp;quot; 输出: false 示例 2： 输入: s = &amp;quot;abc&amp;quot; 输出: true 限制： 0 &amp;lt;= len(s) &amp;lt;= 100 如果你不使用额外的数据结构，会很加分。 题解 1.对字符串排序,比较相邻字符是否相同 bool isUnique(string astr) { if (astr.size() == 0) return true; sort(astr.begin(), astr.end()); for (size_t i = 0; i &amp;lt; astr.size() - 1; i++) { if</description>
    </item>
    
    <item>
      <title>leetcode287题</title>
      <link>https://CorPython.github.io/post/leetcode287%E9%A2%98/</link>
      <pubDate>Wed, 05 Feb 2020 21:01:59 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode287%E9%A2%98/</guid>
      <description>题目 给定一个包含 n+1 个整数的数组 nums,其数字都在 1 到 n 之间（包括 1 和n）,可知至少存在一个重复的整数.假设只有一个重复的整数,找出这个重复的数 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的） 只能使用额外的 O(1) 的空间 时间复杂度小于 O(n^2) 数组中只有一个</description>
    </item>
    
    <item>
      <title>Leetcode349题</title>
      <link>https://CorPython.github.io/post/leetcode349%E9%A2%98/</link>
      <pubDate>Mon, 27 Jan 2020 14:33:37 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode349%E9%A2%98/</guid>
      <description>题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解 Hashset集合 1.使用两个Hashset,首先遍历数组1加入到set1中,再遍历数组2,判</description>
    </item>
    
    <item>
      <title>Leetcode290题</title>
      <link>https://CorPython.github.io/post/leetcode290%E9%A2%98/</link>
      <pubDate>Sun, 26 Jan 2020 22:45:15 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode290%E9%A2%98/</guid>
      <description>题目 给定一种规律 pattern 和一个字符串 str，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat dog&amp;quot; 输出: true 示例 2: 输入:pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat fish&amp;quot; 输出: false 示例3: 输入: pattern = &amp;quot;aaaa&amp;quot;, str = &amp;quot;dog cat</description>
    </item>
    
    <item>
      <title>Leetcode137题</title>
      <link>https://CorPython.github.io/post/leetcode137%E9%A2%98/</link>
      <pubDate>Sun, 26 Jan 2020 16:36:12 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode137%E9%A2%98/</guid>
      <description>题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 示例 1: 输入: [2,2,3,2] 输出: 3 示例 2: 输入: [0,1,0,1,0,1,99] 输出: 99 题解 1.使用哈希表 遍历数组元素,第一次出现的元素加入到哈希表中,出现多次则将value置为false,由于数组中只有一个出现一次</description>
    </item>
    
    <item>
      <title>Leetcode832题</title>
      <link>https://CorPython.github.io/post/leetcode832%E9%A2%98/</link>
      <pubDate>Fri, 24 Jan 2020 15:57:02 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode832%E9%A2%98/</guid>
      <description>题目 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]] 输出: [[1,0,0],[0,1,0],[1,1,1]] 解释: 首</description>
    </item>
    
    <item>
      <title>Leetcode461题</title>
      <link>https://CorPython.github.io/post/leetcode461%E9%A2%98/</link>
      <pubDate>Fri, 24 Jan 2020 13:41:51 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode461%E9%A2%98/</guid>
      <description>题目 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y &amp;lt; 2^31 示例: 输入: x = 1, y = 4 输出: 2 题解 将两个数进行异或操作,数有多少个1即可, java实现 class Solution { public int hammingDistance(int x, int y) { int z = x ^ y; int sum = 0; while(z != 0){ sum += z &amp;amp; 1; z</description>
    </item>
    
    <item>
      <title>Leetcode202题</title>
      <link>https://CorPython.github.io/post/leetcode202%E9%A2%98/</link>
      <pubDate>Fri, 24 Jan 2020 12:56:29 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode202%E9%A2%98/</guid>
      <description>题目 编写一个算法来判断一个数是不是快乐数。 一个快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19 输出: true 解释: 1 * 1 + 9*9 = 82 8*8 + 2*2 = 68 6*6</description>
    </item>
    
    <item>
      <title>Leetcode1281题</title>
      <link>https://CorPython.github.io/post/leetcode1281%E9%A2%98/</link>
      <pubDate>Fri, 24 Jan 2020 12:16:31 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode1281%E9%A2%98/</guid>
      <description>题目 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1： 输入：n = 234 输出：15 解释： 各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2： 输入：n = 4421 输出：21 解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1</description>
    </item>
    
    <item>
      <title>Leetcode20题</title>
      <link>https://CorPython.github.io/post/leetcode20%E9%A2%98/</link>
      <pubDate>Fri, 24 Jan 2020 11:28:59 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode20%E9%A2%98/</guid>
      <description>题目 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &amp;quot;()&amp;quot; 输出: true 示例 2: 输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3: 输入: &amp;quot;(]&amp;quot; 输出: false 示例 4:</description>
    </item>
    
    <item>
      <title>Leetcode1题</title>
      <link>https://CorPython.github.io/post/leetcode1%E9%A2%98/</link>
      <pubDate>Thu, 23 Jan 2020 16:14:05 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode1%E9%A2%98/</guid>
      <description>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数,并返回他们的数组下标。 你可以假设每种输入只会对应一个答案.但是,你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 题解 遍历nums数组,判断t</description>
    </item>
    
    <item>
      <title>Leetcode13题</title>
      <link>https://CorPython.github.io/post/leetcode13%E9%A2%98/</link>
      <pubDate>Thu, 23 Jan 2020 12:43:09 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode13%E9%A2%98/</guid>
      <description>题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。</description>
    </item>
    
    <item>
      <title>Leetcode11题</title>
      <link>https://CorPython.github.io/post/leetcode11%E9%A2%98/</link>
      <pubDate>Thu, 23 Jan 2020 10:41:27 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode11%E9%A2%98/</guid>
      <description>题目 给定 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8</description>
    </item>
    
    <item>
      <title>leetcode1323题</title>
      <link>https://CorPython.github.io/post/6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 22 Jan 2020 18:13:45 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</guid>
      <description>题目 给你一个仅由数字 6 和 9 组成的正整数 num.你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。 请返回你可以得到的最大数字。 测试样例: 输入 6969 9666 输出 9969 9966 题解 1.将数字转化为字符串,遍历字符串,遇到第一个6将其转化为9即可. int maximum69Number (int num) { int res; string strNum; stringstream ss; stringstream sa; ss &amp;lt;&amp;lt; num; ss &amp;gt;&amp;gt; strNum; for (auto &amp;amp;i : strNum) { if (i == &amp;#39;6&amp;#39;)</description>
    </item>
    
    <item>
      <title>leetcode771题</title>
      <link>https://CorPython.github.io/post/%E5%AE%9D%E7%9F%B3%E5%92%8C%E7%9F%B3%E5%A4%B4/</link>
      <pubDate>Wed, 22 Jan 2020 16:43:24 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/%E5%AE%9D%E7%9F%B3%E5%92%8C%E7%9F%B3%E5%A4%B4/</guid>
      <description>题目 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&amp;quot;a&amp;quot;和&amp;quot;A&amp;quot;是不同类型的石头</description>
    </item>
    
    <item>
      <title>Leetcode709题</title>
      <link>https://CorPython.github.io/post/leetcode709/</link>
      <pubDate>Wed, 22 Jan 2020 15:20:05 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode709/</guid>
      <description>写在前面 首先需要知道一般的大小写转换的规则,小写字母对应的ASCII码的值比大写字母大,A对应的是65,a对应的是97,差值为32 所以大小写转换可以这么写: 大写--&amp;gt;小写:(char)(字符 + (&#39;a&#39; - &#39;A&#39;)) 小写--&amp;gt;大写:(char)(字符 - (&#39;a&#39; - &#39;A&#39;)) java实现 class Solution { public String toLowerCase(String str) {</description>
    </item>
    
    <item>
      <title>Leetcode229题</title>
      <link>https://CorPython.github.io/post/leetcode229%E9%A2%98/</link>
      <pubDate>Sun, 19 Jan 2020 15:47:07 +0800</pubDate>
      
      <guid>https://CorPython.github.io/post/leetcode229%E9%A2%98/</guid>
      <description>题目 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1: 输入: [3,2,3] 输出: [3] 示例 2: 输入: [1,1,1,3,3,2,2,2] 输出: [1,2] 题解 1.投票法 由于要求找到的是出现次数超过⌊ n/3 ⌋ 的元素,所以最多可以找到两个不同的数字,假定两个结果候选人者,遍</description>
    </item>
    
  </channel>
</rss>